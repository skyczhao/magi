title: 个人技术总结 2018.05版
date: 2018-05-12 07:59:13
desc: 
tags: [] 
---

初衷是想说记录自己的技术组成，找出短板。
不过放了有点久，忘了整理。。

> 1. 缺少链接
> 2. 格式与规范

<!-- more -->

``` markdown
# 技术总结

## 简介

### 个人信息

### 学习经历

### 工作经历

## 项目

### 大数据项目

#### 数据分析/舆情

#### 自研分布式系统开发

##### 采集平台

###### redis

###### 进程/线程

###### 流式处理

###### 配置化

###### 任务同步

###### 任务管理

####### 增加

####### 清除

####### 恢复/重做

#### 开源项目改造

##### ElasticSearch

###### guice注入

###### Bloom Filter

###### tf/idf

###### query parse

#### 大数据基础平台

##### 分布式任务管理

##### 咨询

###### hbase debug

###### 运维

###### IaaS设计

####### security hadoop

######## kerberoes

######### ticket、token

######### login

######## ranger

######### rwxrwxrwx

####### Hadoop、MapReduce、Hive

####### DaaS

##### ETL

###### hive

###### mapreduce

###### spark

###### 算法调用

### 算法研究项目

#### 推荐项目

##### 绿瘦资料与销售推荐

#### 企业画像

##### 员工

##### 产品/服务

###### 美誉度

##### 市场

###### 市值

###### 行业

##### 风险

### 手机项目

#### 手机微信采集

##### adb shell input

###### 输入

###### 滑动

###### 点击

###### 长按

##### xposed hook

###### imsi

###### phone

###### mac

###### location

##### 模拟登陆

###### accessible service

###### 图像识别-验证码

##### 脚本解析

## 技术

### 基础

#### APUE

#### 进程线程

##### 共享内存

##### 管道

#### IO

##### NIO

##### IO多路复用

#### 网络协议

#### java

##### ArrayList、LinkedList、Vector的区别

###### 线程安全：vector，线程危险：ArrayList, LinkedList

##### gc

###### 分代

####### 新生代

######## eden

######## s0

######### Survivor

######## s1

####### 老年代

####### 持久代

###### 回收算法

####### 复制算法

######## HotSpot虚拟机默认Eden和Survivor的大小比例是8:1:1，也就是说新生代中牺牲掉10%的空间而不是一半的空间

####### 标记-清除算法

####### 标记-整理算法

###### 垃圾收集器

####### 新生代垃圾收集器

######## Serial收集器作用于新生代，是一个单线程收集器，基于复制算法实现。

######## ParNew收集器作用于新生代，是一个多线程收集器，基于复制算法实现。

######## Parallel Scavenge收集器同样作用于新生代，并且也是采用多线程和复制算法来进行垃圾回收。

####### 老年代垃圾收集器

######## Serial Old收集器作用于老年代，采用单线程和标记-整理算法来实现垃圾回收。

########  Parallel Old收集器是Parallel Scavenge收集器的老年代版本，采用多线程和标记-整理算法来实现老年代的垃圾回收。

######## CMS(Concurrent Mark Sweep)收集器是一款真正实现了并发收集的老年代收集器。

##### spring aop

######  spring apo使用

###### 官方文档

#### c++

##### epoll

##### 内存管理

#### linux操作

### 进阶

#### 常规

##### 负载均衡

###### 负载均衡集群

###### nginx负载均衡

####### 对负载均衡的支持方式

######## 轮询

######## weight

######## ip_hash

######## fair

######## url_hash

####### 怎么实现多台服务器之间session的共享

######## 不使用session，换作cookie

######## 应用服务器自行实现共享

######## ip_hash

######### 不能在一些情况下使用

########## nginx不是最前端的服务器

########## nginx的后端还有其它方式的负载均衡

######## upstream_hash

##### 高可用

##### 源码阅读

##### 集群

###### 集群主要分为：高可用集群(High Availability Cluster)，负载均衡集群(Load Balance Cluster，nginx即可实现)，科学计算集群(High Performance Computing Cluster)。

###### 分布式是以缩短单个任务的执行时间来提升效率的，而集群则是通过提高单位时间内执行的任务数来提升效率。

###### 它是根据某种负载策略把请求分发到集群中的每一台服务器上，让整个服务器群来处理网站的请求。

######  在集群服务器架构中，当主服务器故障时，备份服务器能够自动接管主服务器的工作，并及时切换过去，以实现对用户的不间断服务。

##### 数据库引擎对比

###### mysql数据库几种引擎对比

###### myisam vs innodb

###### mysql性能

####### ver 5.7 160万只读 QPS

####### 可以处理拥有上千万条记录的大型数据库

####### Thread Pool功能更能直接通过减少CPU的切换，提升系统在高并发时的吞吐率

##### https://github.com/yingjunwu/DBMS-Indexology

#### 大数据组成

##### 框架

###### spark

###### mr

##### 存储

###### 常见的类型

####### hdfs

####### hive

####### hbase

####### elasticsearch

###### nosql性能比较 

####### hbase

######## CP类型

######### 参考：CAP

####### redis

####### mongodb

##### 算法

###### bit map

###### bloom filter

##### 分布式锁实现

###### 数据库

###### redis

###### zookeeper

#### 安全

##### 缓冲区溢出

##### sql注入

###### prepare statement

##### https

### 算法

#### 机器学习

#### 深度学习

#### 欠拟合

#### 过拟合

#### 优化方法

#### 优化原理

#### 小根堆

##### 小根堆总结 https://blog.csdn.net/ganggexiongqi/article/details/7449970

##### 大根堆小根堆 https://blog.csdn.net/love_gg/article/details/7945561

##### 基本的原理

###### 完全二叉树

###### 从上往下、从左往右编号

####### 变成数组

###### 逐个调整

#### trie树

##### 第六天：熟悉trie树

#### 红黑树

##### 数据库中的应用

#### DFS/BFS

### 架构师

#### 如何设计一个分布式系统

##### 可扩展、高可用、负载均衡网站架构设计方案  

#### 大数据算法应用

##### 十大大数据问题与解法 

######  5、 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？

####### 方案1：可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。考虑采取分而治之的方法。

######## 遍历文件a，对每个url求取hash(url)00，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,...,a999）中。这样每个小文件的大约为300M。

######## 遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,...,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,...,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。

######## 求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。

####### 方案2：如果允许有一定的错误率，可以使用Bloom filter，

######## 4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，

######## 然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。

## 能力

### 基础扎实

### 进阶应用能力

### 算法

#### 大数据

#### 常规算法

### 学习能力
```
